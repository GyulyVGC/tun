#!/usr/bin/env bash
# =============================================================================
#  vxlan-setup.sh — Interactive VXLAN Namespace Builder
#  Tested on Ubuntu 20.04+ / Debian 11+
#  Run as root or with sudo
# =============================================================================

set -euo pipefail

# ── Colours ──────────────────────────────────────────────────────────────────
RED='\033[0;31m';   GREEN='\033[0;32m';  YELLOW='\033[1;33m'
BLUE='\033[0;34m';  CYAN='\033[0;36m';   BOLD='\033[1m'
MAGENTA='\033[0;35m'; DIM='\033[2m';     NC='\033[0m'

# ── Basic output helpers ──────────────────────────────────────────────────────
info()    { echo -e "${CYAN}[INFO]${NC}   $*"; }
success() { echo -e "${GREEN}[OK]${NC}     $*"; }
warn()    { echo -e "${YELLOW}[WARN]${NC}   $*"; }
error()   { echo -e "${RED}[ERROR]${NC}  $*" >&2; }
header()  { echo -e "\n${BOLD}${BLUE}══════════════════════════════════════════${NC}"
            echo -e "${BOLD}${BLUE}  $*${NC}"
            echo -e "${BOLD}${BLUE}══════════════════════════════════════════${NC}\n"; }
hint()    { echo -e "  ${YELLOW}↳ Example: $*${NC}"; }

# ── Inline command preview (shown right after each answer) ────────────────────
# Usage: preview_cmd "comment" "cmd1" "cmd2" ...
preview_cmd() {
    local comment=$1; shift
    echo -e "\n  ${DIM}┌─ Command generated by this answer ───────────────────────${NC}"
    echo -e "  ${DIM}│${NC}  ${MAGENTA}# ${comment}${NC}"
    for cmd in "$@"; do
        echo -e "  ${DIM}│${NC}  ${BOLD}${GREEN}${cmd}${NC}"
    done
    echo -e "  ${DIM}└───────────────────────────────────────────────────────────${NC}\n"
}

# ── Master command log — accumulates every command in sequence ────────────────
declare -a CMD_LOG_COMMENTS=()
declare -a CMD_LOG_BLOCKS=()   # each entry is a newline-separated list of commands

log_cmd() {
    # log_cmd "comment" "cmd1" "cmd2" ...
    local comment=$1; shift
    CMD_LOG_COMMENTS+=("$comment")
    local block=""
    for c in "$@"; do block+="${c}"$'\n'; done
    CMD_LOG_BLOCKS+=("$block")
}

# ── Prompt helpers ────────────────────────────────────────────────────────────
ask_input() {
    local __var=$1 question=$2 example=$3 default=$4
    echo ""
    echo -e "${BOLD}${question}${NC}"
    [[ -n "$example" ]] && hint "$example"
    [[ -n "$default" ]] && echo -e "  ${YELLOW}↳ Press Enter to accept default: ${BOLD}${default}${NC}"
    read -rp "  > " __input
    [[ -z "$__input" && -n "$default" ]] && __input="$default"
    printf -v "$__var" '%s' "$__input"
}

ask_yn() {
    local question=$1 default=${2:-y}
    local prompt="[Y/n]"; [[ "$default" == "n" ]] && prompt="[y/N]"
    echo ""
    echo -e "${BOLD}${question}${NC} ${YELLOW}${prompt}${NC}"
    read -rp "  > " __yn
    __yn="${__yn:-$default}"
    [[ "${__yn,,}" == "y" || "${__yn,,}" == "yes" ]]
}

# ── Validators ────────────────────────────────────────────────────────────────
validate_cidr() {
    local cidr=$1
    [[ "$cidr" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]] || return 1
    local ip="${cidr%%/*}" prefix="${cidr##*/}"
    [[ "$prefix" -ge 0 && "$prefix" -le 32 ]] || return 1
    local IFS='.'; read -ra octs <<< "$ip"
    for o in "${octs[@]}"; do [[ "$o" -ge 0 && "$o" -le 255 ]] || return 1; done
    return 0
}

validate_ip() {
    local ip=$1
    [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
    local IFS='.'; read -ra octs <<< "$ip"
    for o in "${octs[@]}"; do [[ "$o" -ge 0 && "$o" -le 255 ]] || return 1; done
    return 0
}

cidr_network() {
    local ip="${1%%/*}" prefix="${1##*/}"
    local IFS='.'; read -ra octs <<< "$ip"
    local ipint=$(( (octs[0]<<24)|(octs[1]<<16)|(octs[2]<<8)|octs[3] ))
    local mask=$(( 0xFFFFFFFF << (32-prefix) & 0xFFFFFFFF ))
    local net=$(( ipint & mask ))
    echo "$(( (net>>24)&255 )).$(( (net>>16)&255 )).$(( (net>>8)&255 )).$(( net&255 ))/${prefix}"
}

cidr_ip()     { echo "${1%%/*}"; }
cidr_prefix() { echo "${1##*/}"; }

iface_exists() { ip link show "$1" &>/dev/null; }
ns_exists()    { ip netns list 2>/dev/null | grep -qw "$1"; }

# ── Rollback tracker ──────────────────────────────────────────────────────────
declare -a ROLLBACK_CMDS=()
push_rollback() { ROLLBACK_CMDS+=("$1"); }

rollback_all() {
    [[ ${#ROLLBACK_CMDS[@]} -eq 0 ]] && return
    warn "Rolling back changes..."
    for (( idx=${#ROLLBACK_CMDS[@]}-1; idx>=0; idx-- )); do
        eval "${ROLLBACK_CMDS[$idx]}" 2>/dev/null || true
    done
    warn "Rollback complete."
}

trap 'error "Unexpected error on line $LINENO. Running rollback..."; rollback_all; exit 1' ERR

# ── Root & tool checks ────────────────────────────────────────────────────────
if [[ $EUID -ne 0 ]]; then
    error "This script must be run as root."
    echo -e "  Try: ${BOLD}sudo bash $0${NC}"; exit 1
fi

for tool in ip ping; do
    command -v "$tool" &>/dev/null || {
        error "Required tool '$tool' not found. Install iproute2."; exit 1; }
done

# =============================================================================
#  BANNER
# =============================================================================
clear
echo -e "${BOLD}${CYAN}"
cat <<'EOF'
  __   ____  __    _   _  _       ____  ____  ____  _  _  ____
 \ \ / /\ \/ /   | | | |/ \     / ___||  __||_  _|| || ||  _ \
  \ V /  >  <    | |_| |\_/     \___ \| |_    | |  | || || |_) |
   \_/  /_/\_\    \___/ _        |___/|____|  |_|  |_||_||____/
                        |_|
EOF
echo -e "${NC}"
echo -e "${BOLD}  Interactive VXLAN Namespace Builder${NC}"
echo -e "  ${YELLOW}After each answer the exact command it generates will be shown.${NC}"
echo -e "  ${YELLOW}A complete list of ALL commands is shown before anything runs.${NC}\n"

# =============================================================================
#  STEP 1 — Underlay network
# =============================================================================
header "STEP 1 — Physical Host Network (Underlay)"

echo -e "  This is the ${BOLD}real${NC} IP address of this machine on the physical network."
echo -e "  VXLAN tunnels are built on top of these physical addresses.\n"

echo -e "${BOLD}  Available network interfaces:${NC}"
ip -brief addr show | grep -v "^lo" | awk '{printf "    %-15s %-12s %s\n", $1, $2, $3}'
echo ""

# Auto-detect this machine's primary IP (first non-loopback address)
DETECTED_LOCAL_IP=$(ip route get 1.1.1.1 2>/dev/null | grep -oP 'src \K\S+' | head -1 || true)
if [[ -z "$DETECTED_LOCAL_IP" ]]; then
    DETECTED_LOCAL_IP=$(ip -4 addr show | grep -v "127\." | grep -oP '(?<=inet )\d+\.\d+\.\d+\.\d+' | head -1 || true)
fi

while true; do
    ask_input LOCAL_IP "Enter THIS machine's physical IP address:" \
        "172.16.70.135" "${DETECTED_LOCAL_IP:-}"
    validate_ip "$LOCAL_IP" && break
    error "Invalid IP: '$LOCAL_IP'"
done

while true; do
    ask_input REMOTE_IP "Enter the REMOTE machine's physical IP address:" \
        "172.16.70.136" ""
    validate_ip "$REMOTE_IP" && break
    error "Invalid IP: '$REMOTE_IP'"
done

DETECTED_IFACE=$(ip route get "$REMOTE_IP" 2>/dev/null | grep -oP 'dev \K\S+' | head -1 || true)
IFACE_DEFAULT="${DETECTED_IFACE:-ens18}"

while true; do
    ask_input PHYS_IFACE "Physical interface name for VXLAN (auto-detected: ${IFACE_DEFAULT}):" \
        "ens18  or  eth0" "$IFACE_DEFAULT"
    iface_exists "$PHYS_IFACE" && break
    error "Interface '$PHYS_IFACE' does not exist."
done

while true; do
    ask_input VXLAN_PORT "VXLAN UDP destination port (IANA standard is 4789):" \
        "4789" "4789"
    [[ "$VXLAN_PORT" =~ ^[0-9]+$ && "$VXLAN_PORT" -ge 1 && "$VXLAN_PORT" -le 65535 ]] && break
    error "Port must be 1–65535."
done

echo -e "\n  ${DIM}┌─ Underlay values recorded (used in every VXLAN command) ─${NC}"
echo -e "  ${DIM}│${NC}  ${MAGENTA}# local = this machine, remote = other machine${NC}"
echo -e "  ${DIM}│${NC}  ${BOLD}${GREEN}local  = ${LOCAL_IP}${NC}"
echo -e "  ${DIM}│${NC}  ${BOLD}${GREEN}remote = ${REMOTE_IP}${NC}"
echo -e "  ${DIM}│${NC}  ${BOLD}${GREEN}dev    = ${PHYS_IFACE}${NC}"
echo -e "  ${DIM}│${NC}  ${BOLD}${GREEN}port   = ${VXLAN_PORT}${NC}"
echo -e "  ${DIM}└───────────────────────────────────────────────────────────${NC}\n"

success "Underlay configured."

# =============================================================================
#  STEP 2 — Namespace count
# =============================================================================
header "STEP 2 — Number of Namespaces"

echo -e "  Each namespace is a fully isolated network stack (like a lightweight VM).\n"

while true; do
    ask_input NS_COUNT "How many namespaces to create on this machine?" \
        "1   or   2   or   3" "1"
    [[ "$NS_COUNT" =~ ^[0-9]+$ && "$NS_COUNT" -ge 1 && "$NS_COUNT" -le 10 ]] && break
    error "Enter a number between 1 and 10."
done

success "Will create $NS_COUNT namespace(s)."

# =============================================================================
#  STEP 3 — First bridge name
# =============================================================================
header "STEP 3 — First Bridge"

echo -e "  A Linux bridge is a virtual switch that connects your namespace to the VXLAN."
echo -e "  The bridge IP becomes the default gateway for the namespace.\n"

while true; do
    ask_input BRIDGE1_NAME "Name for the first bridge interface:" \
        "bridge-01   or   br0   or   vxlan-br" "bridge-01"
    [[ "$BRIDGE1_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]{0,14}$ ]] || {
        error "Start with a letter, max 15 chars, letters/digits/-/_ only."; continue; }
    iface_exists "$BRIDGE1_NAME" && {
        warn "Interface '$BRIDGE1_NAME' already exists."
        ask_yn "Delete and recreate it?" "n" && {
            ip link set "$BRIDGE1_NAME" down 2>/dev/null || true
            ip link delete "$BRIDGE1_NAME" 2>/dev/null || true
        } || { error "Choose a different bridge name."; continue; }
    }
    break
done

# Bridge creation commands are logged after the gateway IP is known (Step 4)
# but we preview the structural command now
preview_cmd "Create bridge interface (gateway IP finalised after namespace IP is set)" \
    "ip link add ${BRIDGE1_NAME} type bridge" \
    "ip addr add <gateway-cidr> dev ${BRIDGE1_NAME}   ← finalised in next step" \
    "ip link set ${BRIDGE1_NAME} up"

# =============================================================================
#  STEP 4 — Namespace details loop
# =============================================================================
header "STEP 4 — Namespace Details"

declare -a NS_NAMES=()
declare -a NS_CIDRS=()
declare -a NS_VIN_NAMES=()
declare -a NS_VOUT_NAMES=()
declare -a NS_BRIDGE_NAMES=()
declare -a NS_BRIDGE_GW_IPS=()
declare -a NS_VXLAN_NAMES=()
declare -a NS_VXLAN_IDS=()
declare -A BRIDGE_GW_MAP=()
NEXT_VNI=100
BRIDGE1_LOGGED=false   # track whether we've finalised bridge1's log entry
NS_CIDR_THIRD_OCTET=1   # increments per namespace: 10.1.1.1/24, 10.1.2.1/24, ...

for (( i=1; i<=NS_COUNT; i++ )); do
    echo -e "\n${BOLD}${YELLOW}── Namespace $i of $NS_COUNT ──────────────────────────────${NC}\n"

    # ── Namespace name ────────────────────────────────────────────────────────
    while true; do
        ask_input NS_NAME "Name for namespace $i:" \
            "red   or   blue   or   green   or   ns-app1" "ns${i}"
        [[ "$NS_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]{0,14}$ ]] || {
            error "Letters/digits/-/_ only, max 15 chars, start with letter."; continue; }
        ns_exists "$NS_NAME" && {
            warn "Namespace '$NS_NAME' already exists."
            ask_yn "Delete and recreate it?" "n" && \
                ip netns del "$NS_NAME" 2>/dev/null || true || \
                { error "Choose a different name."; continue; }
        }
        break
    done

    preview_cmd "Create network namespace" \
        "ip netns add ${NS_NAME}"
    log_cmd "Create namespace '${NS_NAME}'" \
        "ip netns add ${NS_NAME}"

    # ── Namespace IP ──────────────────────────────────────────────────────────
    NS_CIDR_DEFAULT="10.1.${NS_CIDR_THIRD_OCTET}.1/24"
    while true; do
        ask_input NS_CIDR "IP address + prefix for '${NS_NAME}' interface (CIDR):" \
            "10.1.1.1/24   or   192.168.60.13/16   or   172.20.0.5/24" "${NS_CIDR_DEFAULT}"
        validate_cidr "$NS_CIDR" && break
        error "Invalid CIDR. Format: X.X.X.X/prefix  e.g. 10.1.1.1/24"
    done
    NS_CIDR_THIRD_OCTET=$(( NS_CIDR_THIRD_OCTET + 1 ))

    NS_IP=$(cidr_ip "$NS_CIDR")
    NS_PREFIX=$(cidr_prefix "$NS_CIDR")

    # ── veth pair names ───────────────────────────────────────────────────────
    echo ""
    echo -e "  ${BOLD}veth pair${NC}: virtual cable — ${CYAN}*-in${NC} lives inside the namespace,"
    echo -e "  ${CYAN}*-out${NC} lives on the host and plugs into the bridge.\n"

    while true; do
        ask_input VIN_NAME "veth interface name INSIDE namespace '${NS_NAME}':" \
            "${NS_NAME}-in   or   eth0" "${NS_NAME}-in"
        [[ "$VIN_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]{0,14}$ ]] && break
        error "Invalid interface name."
    done

    while true; do
        ask_input VOUT_NAME "veth interface name on the HOST side (plugs into bridge):" \
            "${NS_NAME}-out   or   veth-${NS_NAME}" "${NS_NAME}-out"
        [[ "$VOUT_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]{0,14}$ ]] && break
        error "Invalid interface name."
    done

    preview_cmd "Create veth pair, move ${VIN_NAME} into namespace, assign IP" \
        "ip link add ${VIN_NAME} type veth peer name ${VOUT_NAME}" \
        "ip link set ${VIN_NAME} netns ${NS_NAME}" \
        "ip netns exec ${NS_NAME} ip addr add ${NS_CIDR} dev ${VIN_NAME}" \
        "ip netns exec ${NS_NAME} ip link set ${VIN_NAME} up" \
        "ip netns exec ${NS_NAME} ip link set lo up"
    log_cmd "Create veth pair and configure ${NS_NAME} interface" \
        "ip link add ${VIN_NAME} type veth peer name ${VOUT_NAME}" \
        "ip link set ${VIN_NAME} netns ${NS_NAME}" \
        "ip netns exec ${NS_NAME} ip addr add ${NS_CIDR} dev ${VIN_NAME}" \
        "ip netns exec ${NS_NAME} ip link set ${VIN_NAME} up" \
        "ip netns exec ${NS_NAME} ip link set lo up"

    # ── Bridge selection ──────────────────────────────────────────────────────
    CHOSEN_BRIDGE="$BRIDGE1_NAME"

    if [[ $i -gt 1 ]]; then
        echo ""
        echo -e "  ${BOLD}Bridge options for '${NS_NAME}':${NC}\n"
        echo -e "  ${BOLD}Bridges configured so far:${NC}"
        for bname in "${!BRIDGE_GW_MAP[@]}"; do
            echo -e "    ${CYAN}${bname}${NC}  →  gateway ${BRIDGE_GW_MAP[$bname]}"
        done
        echo ""

        if ask_yn "Attach '${NS_NAME}' to an existing bridge?" "y"; then
            BRIDGE_NAMES_LIST=( "${!BRIDGE_GW_MAP[@]}" )
            if [[ ${#BRIDGE_NAMES_LIST[@]} -eq 1 ]]; then
                CHOSEN_BRIDGE="${BRIDGE_NAMES_LIST[0]}"
                info "Using bridge: $CHOSEN_BRIDGE"
            else
                while true; do
                    ask_input CHOSEN_BRIDGE "Which bridge?" \
                        "${BRIDGE_NAMES_LIST[*]}" "${BRIDGE_NAMES_LIST[0]}"
                    [[ -v "BRIDGE_GW_MAP[$CHOSEN_BRIDGE]" ]] && break
                    error "Not found. Choose from: ${BRIDGE_NAMES_LIST[*]}"
                done
            fi

            EXISTING_GW="${BRIDGE_GW_MAP[$CHOSEN_BRIDGE]}"
            NS_NET=$(cidr_network "$NS_CIDR")
            GW_NET=$(cidr_network "$EXISTING_GW")

            if [[ "$NS_NET" == "$GW_NET" ]]; then
                CHOSEN_BRIDGE_GW=$(cidr_ip "$EXISTING_GW")
                success "Same subnet as existing gateway $(cidr_ip "$EXISTING_GW") — no extra bridge IP needed."

                preview_cmd "Attach ${VOUT_NAME} to ${CHOSEN_BRIDGE}, set default route" \
                    "ip link set ${VOUT_NAME} master ${CHOSEN_BRIDGE}" \
                    "ip link set ${VOUT_NAME} up" \
                    "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
                log_cmd "Attach ${VOUT_NAME} to ${CHOSEN_BRIDGE} and set default route in ${NS_NAME}" \
                    "ip link set ${VOUT_NAME} master ${CHOSEN_BRIDGE}" \
                    "ip link set ${VOUT_NAME} up" \
                    "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
                NS_BRIDGE_GW_IPS+=("$EXISTING_GW")
            else
                warn "Subnet mismatch: ${NS_NAME} is on $(cidr_network "$NS_CIDR") but ${CHOSEN_BRIDGE} gateway is on $(cidr_network "$EXISTING_GW")."
                echo -e "\n  ${BOLD}A new gateway IP in the namespace subnet must be added to the bridge.${NC}\n"

                SUGGESTED_GW_LAST=$(( (${NS_IP##*.} == 1) ? 2 : 1 ))
                SUGGESTED_GW="${NS_IP%.*}.${SUGGESTED_GW_LAST}/${NS_PREFIX}"

                while true; do
                    ask_input NEW_BRIDGE_CIDR \
                        "New gateway IP/prefix for bridge '${CHOSEN_BRIDGE}' in this subnet:" \
                        "$SUGGESTED_GW" "$SUGGESTED_GW"
                    validate_cidr "$NEW_BRIDGE_CIDR" || { error "Invalid CIDR."; continue; }
                    [[ "$(cidr_network "$NEW_BRIDGE_CIDR")" == "$(cidr_network "$NS_CIDR")" ]] && break
                    error "Must be in the same subnet as namespace IP $NS_CIDR"
                done
                CHOSEN_BRIDGE_GW=$(cidr_ip "$NEW_BRIDGE_CIDR")

                preview_cmd "Add new subnet IP to ${CHOSEN_BRIDGE}, attach ${VOUT_NAME}, set default route" \
                    "ip addr add ${NEW_BRIDGE_CIDR} dev ${CHOSEN_BRIDGE}" \
                    "ip link set ${VOUT_NAME} master ${CHOSEN_BRIDGE}" \
                    "ip link set ${VOUT_NAME} up" \
                    "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
                log_cmd "Add ${NEW_BRIDGE_CIDR} to ${CHOSEN_BRIDGE}, attach ${VOUT_NAME}, route in ${NS_NAME}" \
                    "ip addr add ${NEW_BRIDGE_CIDR} dev ${CHOSEN_BRIDGE}" \
                    "ip link set ${VOUT_NAME} master ${CHOSEN_BRIDGE}" \
                    "ip link set ${VOUT_NAME} up" \
                    "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
                NS_BRIDGE_GW_IPS+=("$NEW_BRIDGE_CIDR")
            fi
        else
            # New bridge
            while true; do
                NEXT_BR_NUM=$(printf "%02d" $(( ${#BRIDGE_GW_MAP[@]} + 1 )) )
                ask_input NEW_BRIDGE_NAME "Name for the new bridge:" \
                    "bridge-02   or   br-${NS_NAME}   or   vxbr${i}" "bridge-${NEXT_BR_NUM}"
                [[ "$NEW_BRIDGE_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]{0,14}$ ]] || {
                    error "Invalid name."; continue; }
                iface_exists "$NEW_BRIDGE_NAME" && {
                    warn "'$NEW_BRIDGE_NAME' already exists."
                    ask_yn "Delete and recreate?" "n" && {
                        ip link set "$NEW_BRIDGE_NAME" down 2>/dev/null || true
                        ip link delete "$NEW_BRIDGE_NAME" 2>/dev/null || true
                    } || continue
                }
                break
            done
            CHOSEN_BRIDGE="$NEW_BRIDGE_NAME"

            SUGGESTED_GW_LAST=$(( (${NS_IP##*.} == 1) ? 2 : 1 ))
            SUGGESTED_GW="${NS_IP%.*}.${SUGGESTED_GW_LAST}/${NS_PREFIX}"

            while true; do
                ask_input NEW_BRIDGE_GW_CIDR \
                    "Gateway IP/prefix for bridge '${CHOSEN_BRIDGE}' (must be in namespace subnet):" \
                    "$SUGGESTED_GW" "$SUGGESTED_GW"
                validate_cidr "$NEW_BRIDGE_GW_CIDR" || { error "Invalid CIDR."; continue; }
                [[ "$(cidr_network "$NEW_BRIDGE_GW_CIDR")" == "$(cidr_network "$NS_CIDR")" ]] && break
                error "Must be in the same subnet as namespace IP $NS_CIDR"
            done
            CHOSEN_BRIDGE_GW=$(cidr_ip "$NEW_BRIDGE_GW_CIDR")
            BRIDGE_GW_MAP["$CHOSEN_BRIDGE"]="$NEW_BRIDGE_GW_CIDR"

            preview_cmd "Create new bridge ${CHOSEN_BRIDGE}, attach ${VOUT_NAME}, set default route" \
                "ip link add ${CHOSEN_BRIDGE} type bridge" \
                "ip addr add ${NEW_BRIDGE_GW_CIDR} dev ${CHOSEN_BRIDGE}" \
                "ip link set ${CHOSEN_BRIDGE} up" \
                "ip link set ${VOUT_NAME} master ${CHOSEN_BRIDGE}" \
                "ip link set ${VOUT_NAME} up" \
                "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
            log_cmd "Create bridge ${CHOSEN_BRIDGE}, attach ${VOUT_NAME}, route in ${NS_NAME}" \
                "ip link add ${CHOSEN_BRIDGE} type bridge" \
                "ip addr add ${NEW_BRIDGE_GW_CIDR} dev ${CHOSEN_BRIDGE}" \
                "ip link set ${CHOSEN_BRIDGE} up" \
                "ip link set ${VOUT_NAME} master ${CHOSEN_BRIDGE}" \
                "ip link set ${VOUT_NAME} up" \
                "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
            NS_BRIDGE_GW_IPS+=("$NEW_BRIDGE_GW_CIDR")
        fi
    else
        # ── First namespace: finalise bridge1 with gateway ────────────────────
        echo ""
        echo -e "  ${BOLD}Gateway IP for bridge '${BRIDGE1_NAME}':${NC}"
        echo -e "  Must be in the same subnet as the namespace so the namespace can use"
        echo -e "  it as its default gateway.\n"

        SUGGESTED_GW_LAST=$(( (${NS_IP##*.} == 1) ? 2 : 1 ))
        SUGGESTED_GW="${NS_IP%.*}.${SUGGESTED_GW_LAST}/${NS_PREFIX}"

        while true; do
            ask_input BRIDGE1_GW_CIDR "Gateway IP/prefix for bridge '${BRIDGE1_NAME}':" \
                "$SUGGESTED_GW" "$SUGGESTED_GW"
            validate_cidr "$BRIDGE1_GW_CIDR" || { error "Invalid CIDR."; continue; }
            [[ "$(cidr_network "$BRIDGE1_GW_CIDR")" == "$(cidr_network "$NS_CIDR")" ]] && break
            error "Must be in the same subnet as namespace IP $NS_CIDR"
        done
        CHOSEN_BRIDGE_GW=$(cidr_ip "$BRIDGE1_GW_CIDR")
        BRIDGE_GW_MAP["$BRIDGE1_NAME"]="$BRIDGE1_GW_CIDR"

        # Now we know the full bridge1 create command — log it
        log_cmd "Create bridge '${BRIDGE1_NAME}' with gateway ${BRIDGE1_GW_CIDR}" \
            "ip link add ${BRIDGE1_NAME} type bridge" \
            "ip addr add ${BRIDGE1_GW_CIDR} dev ${BRIDGE1_NAME}" \
            "ip link set ${BRIDGE1_NAME} up"
        BRIDGE1_LOGGED=true

        preview_cmd "Assign gateway to bridge '${BRIDGE1_NAME}' — full bridge create command" \
            "ip link add ${BRIDGE1_NAME} type bridge" \
            "ip addr add ${BRIDGE1_GW_CIDR} dev ${BRIDGE1_NAME}" \
            "ip link set ${BRIDGE1_NAME} up"

        preview_cmd "Attach ${VOUT_NAME} to ${BRIDGE1_NAME}, set default route in ${NS_NAME}" \
            "ip link set ${VOUT_NAME} master ${BRIDGE1_NAME}" \
            "ip link set ${VOUT_NAME} up" \
            "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
        log_cmd "Attach ${VOUT_NAME} to ${BRIDGE1_NAME} and set default route in ${NS_NAME}" \
            "ip link set ${VOUT_NAME} master ${BRIDGE1_NAME}" \
            "ip link set ${VOUT_NAME} up" \
            "ip netns exec ${NS_NAME} ip route add default via ${CHOSEN_BRIDGE_GW}"
        NS_BRIDGE_GW_IPS+=("$BRIDGE1_GW_CIDR")
    fi

    # ── VXLAN interface name ──────────────────────────────────────────────────
    echo ""
    echo -e "  ${BOLD}VXLAN interface${NC}: wraps L2 frames inside UDP packets for transport"
    echo -e "  across the physical network. Attached to the bridge as another port.\n"

    while true; do
        ask_input VXLAN_NAME "Name for the VXLAN interface:" \
            "vxlan-${NS_NAME}   or   vxlan${i}   or   vtep${i}" "vxlan-${NS_NAME}"
        [[ "$VXLAN_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]{0,14}$ ]] && break
        error "Invalid interface name."
    done

    # ── VNI ───────────────────────────────────────────────────────────────────
    echo ""
    echo -e "  ${BOLD}VNI (VXLAN Network Identifier)${NC}: Both machines MUST use the same VNI"
    echo -e "  to communicate. Think of it like a VLAN tag. Range: 1–16777215.\n"

    while true; do
        ask_input VXLAN_ID "VNI for this tunnel:" \
            "100   or   200   or   1000" "$NEXT_VNI"
        [[ "$VXLAN_ID" =~ ^[0-9]+$ && "$VXLAN_ID" -ge 1 && "$VXLAN_ID" -le 16777215 ]] && break
        error "VNI must be 1–16777215."
    done
    NEXT_VNI=$(( VXLAN_ID + 100 ))

    preview_cmd "Create VXLAN '${VXLAN_NAME}' (VNI=${VXLAN_ID}) and attach to bridge '${CHOSEN_BRIDGE}'" \
        "ip link add ${VXLAN_NAME} type vxlan id ${VXLAN_ID} local ${LOCAL_IP} remote ${REMOTE_IP} dstport ${VXLAN_PORT} dev ${PHYS_IFACE}" \
        "ip link set ${VXLAN_NAME} master ${CHOSEN_BRIDGE}" \
        "ip link set ${VXLAN_NAME} up"
    log_cmd "Create VXLAN '${VXLAN_NAME}' (VNI=${VXLAN_ID}) and attach to ${CHOSEN_BRIDGE}" \
        "ip link add ${VXLAN_NAME} type vxlan id ${VXLAN_ID} local ${LOCAL_IP} remote ${REMOTE_IP} dstport ${VXLAN_PORT} dev ${PHYS_IFACE}" \
        "ip link set ${VXLAN_NAME} master ${CHOSEN_BRIDGE}" \
        "ip link set ${VXLAN_NAME} up"

    # Store
    NS_NAMES+=("$NS_NAME")
    NS_CIDRS+=("$NS_CIDR")
    NS_VIN_NAMES+=("$VIN_NAME")
    NS_VOUT_NAMES+=("$VOUT_NAME")
    NS_BRIDGE_NAMES+=("$CHOSEN_BRIDGE")
    NS_VXLAN_NAMES+=("$VXLAN_NAME")
    NS_VXLAN_IDS+=("$VXLAN_ID")

    success "Namespace $i collected: ${NS_NAME} (${NS_CIDR}) → bridge ${CHOSEN_BRIDGE} → ${VXLAN_NAME} [VNI ${VXLAN_ID}]"
done

# =============================================================================
#  STEP 5 — IP Forwarding
# =============================================================================
header "STEP 5 — IP Forwarding"

CURRENT_FWD=$(cat /proc/sys/net/ipv4/ip_forward)
echo -e "  Current ip_forward value: ${BOLD}${CURRENT_FWD}${NC} $([ "$CURRENT_FWD" == "1" ] && echo "(already enabled)" || echo "(disabled)")\n"

echo -e "  ${BOLD}When to enable:${NC}"
echo -e "  ${GREEN}YES${NC} — namespaces on ${BOLD}different subnets${NC} on this host need to talk to each other"
echo -e "       e.g. 192.168.60.0/16 and 10.1.1.0/24 both local on this machine\n"
echo -e "  ${YELLOW}NO${NC}  — all namespaces share the ${BOLD}same subnet${NC}, or traffic only flows"
echo -e "       ${BOLD}between machines via VXLAN${NC} (not between local subnets)"
echo -e "       e.g. red (.60.13 on Machine 1) ↔ blue (.60.15 on Machine 2)\n"

if ask_yn "Enable IP forwarding?" "n"; then
    ENABLE_FWD=true
    preview_cmd "Enable IP forwarding on the host kernel" \
        "sysctl -w net.ipv4.ip_forward=1"
    log_cmd "Enable IP forwarding" \
        "sysctl -w net.ipv4.ip_forward=1"
else
    ENABLE_FWD=false
    echo -e "\n  ${DIM}┌─ IP forwarding ───────────────────────────────────────────${NC}"
    echo -e "  ${DIM}│${NC}  ${MAGENTA}# ip_forward will NOT be changed${NC}"
    echo -e "  ${DIM}└───────────────────────────────────────────────────────────${NC}\n"
fi

# =============================================================================
#  STEP 6 — Full command list before execution
# =============================================================================
header "STEP 6 — Complete Command List"

echo -e "  ${BOLD}Every command that will be executed, in order:${NC}"
echo -e "  ${YELLOW}Review carefully before confirming.${NC}\n"
echo -e "  ${DIM}┌──────────────────────────────────────────────────────────────${NC}"

for (( idx=0; idx<${#CMD_LOG_BLOCKS[@]}; idx++ )); do
    echo -e "  ${DIM}│${NC}"
    echo -e "  ${DIM}│${NC}  ${MAGENTA}# ${CMD_LOG_COMMENTS[$idx]}${NC}"
    while IFS= read -r cmdline; do
        [[ -z "$cmdline" ]] && continue
        echo -e "  ${DIM}│${NC}  ${BOLD}${GREEN}${cmdline}${NC}"
    done <<< "${CMD_LOG_BLOCKS[$idx]}"
done

echo -e "  ${DIM}│${NC}"
echo -e "  ${DIM}└──────────────────────────────────────────────────────────────${NC}\n"

total_cmds=0
for block in "${CMD_LOG_BLOCKS[@]}"; do
    while IFS= read -r line; do
        [[ -n "$line" ]] && (( total_cmds++ )) || true
    done <<< "$block"
done

echo -e "  Command groups : ${CYAN}${#CMD_LOG_BLOCKS[@]}${NC}"
echo -e "  Total commands : ${CYAN}${total_cmds}${NC}"
echo -e "  Namespaces     : ${CYAN}${NS_COUNT}${NC}"
echo -e "  IP forwarding  : ${CYAN}${ENABLE_FWD}${NC}\n"

if ! ask_yn "Execute all commands now?" "y"; then
    info "Aborted. No changes were made to the system."
    exit 0
fi

# =============================================================================
#  STEP 7 — Execute
# =============================================================================
header "STEP 7 — Executing Configuration"

if $ENABLE_FWD; then
    sysctl -w net.ipv4.ip_forward=1 >/dev/null
    success "sysctl -w net.ipv4.ip_forward=1"
fi

declare -A CREATED_BRIDGES=()

for (( i=0; i<NS_COUNT; i++ )); do
    NS="${NS_NAMES[$i]}"
    NS_CIDR="${NS_CIDRS[$i]}"
    NS_IP=$(cidr_ip "$NS_CIDR")
    VIN="${NS_VIN_NAMES[$i]}"
    VOUT="${NS_VOUT_NAMES[$i]}"
    BR="${NS_BRIDGE_NAMES[$i]}"
    BR_GW_CIDR="${NS_BRIDGE_GW_IPS[$i]}"
    BR_GW_IP=$(cidr_ip "$BR_GW_CIDR")
    VXLAN="${NS_VXLAN_NAMES[$i]}"
    VNI="${NS_VXLAN_IDS[$i]}"

    echo -e "\n${BOLD}${YELLOW}  ── Namespace $((i+1)): ${NS} ──${NC}\n"

    ip netns add "$NS"
    push_rollback "ip netns del $NS"
    success "ip netns add $NS"

    ip link add "$VIN" type veth peer name "$VOUT"
    push_rollback "ip link del $VIN"
    success "ip link add $VIN type veth peer name $VOUT"

    ip link set "$VIN" netns "$NS"
    success "ip link set $VIN netns $NS"

    ip netns exec "$NS" ip addr add "$NS_CIDR" dev "$VIN"
    ip netns exec "$NS" ip link set "$VIN" up
    ip netns exec "$NS" ip link set lo up
    success "ip netns exec $NS ip addr add $NS_CIDR dev $VIN  [+up]"

    if [[ ! -v "CREATED_BRIDGES[$BR]" ]]; then
        ip link add "$BR" type bridge
        push_rollback "ip link del $BR"
        ip addr add "$BR_GW_CIDR" dev "$BR"
        ip link set "$BR" up
        CREATED_BRIDGES["$BR"]=1
        success "ip link add $BR type bridge  +  ip addr add $BR_GW_CIDR dev $BR"
    else
        NS_NET=$(cidr_network "$NS_CIDR")
        ALREADY_HAS=false
        while IFS= read -r existing; do
            [[ -z "$existing" ]] && continue
            [[ "$(cidr_network "$existing")" == "$NS_NET" ]] && ALREADY_HAS=true && break
        done < <(ip addr show "$BR" | awk '/inet /{print $2}')
        if ! $ALREADY_HAS; then
            ip addr add "$BR_GW_CIDR" dev "$BR"
            success "ip addr add $BR_GW_CIDR dev $BR  (additional subnet)"
        else
            info "Bridge $BR already covers $NS_NET — skipping extra IP."
        fi
    fi

    ip netns exec "$NS" ip route add default via "$BR_GW_IP"
    success "ip netns exec $NS ip route add default via $BR_GW_IP"

    ip link set "$VOUT" master "$BR"
    ip link set "$VOUT" up
    success "ip link set $VOUT master $BR  [+up]"

    ip link add "$VXLAN" type vxlan \
        id "$VNI" local "$LOCAL_IP" remote "$REMOTE_IP" \
        dstport "$VXLAN_PORT" dev "$PHYS_IFACE"
    push_rollback "ip link del $VXLAN"
    success "ip link add $VXLAN type vxlan id $VNI local $LOCAL_IP remote $REMOTE_IP dstport $VXLAN_PORT dev $PHYS_IFACE"

    ip link set "$VXLAN" master "$BR"
    ip link set "$VXLAN" up
    success "ip link set $VXLAN master $BR  [+up]"
done

# =============================================================================
#  STEP 8 — Verification
# =============================================================================
header "STEP 8 — Verification"

ALL_OK=true

for (( i=0; i<NS_COUNT; i++ )); do
    NS="${NS_NAMES[$i]}"
    VIN="${NS_VIN_NAMES[$i]}"
    BR="${NS_BRIDGE_NAMES[$i]}"
    VXLAN="${NS_VXLAN_NAMES[$i]}"

    ns_exists "$NS" && \
        success "Namespace '$NS' exists" || { error "Namespace '$NS' missing!"; ALL_OK=false; }

    ip netns exec "$NS" ip link show "$VIN" 2>/dev/null | grep -q "UP" && \
        success "'$VIN' is UP inside $NS" || { warn "$VIN may not be UP"; ALL_OK=false; }

    iface_exists "$BR" && ip link show "$BR" | grep -q "UP" && \
        success "Bridge '$BR' is UP" || { error "Bridge '$BR' not UP!"; ALL_OK=false; }

    iface_exists "$VXLAN" && ip link show "$VXLAN" | grep -q "UP" && \
        success "VXLAN '$VXLAN' is UP" || { error "VXLAN '$VXLAN' not UP!"; ALL_OK=false; }

    echo -e "\n  ${BOLD}Routing table inside '${NS}':${NC}"
    ip netns exec "$NS" ip route show | sed 's/^/    /'
    echo ""
done

# =============================================================================
#  STEP 9 — Next steps
# =============================================================================
header "STEP 9 — What to Do Next"

echo -e "  ${BOLD}On the REMOTE machine (${REMOTE_IP}), run the same script with:${NC}\n"
echo -e "  ${YELLOW}  Local IP   → $REMOTE_IP${NC}"
echo -e "  ${YELLOW}  Remote IP  → $LOCAL_IP${NC}"
echo -e "  ${YELLOW}  Same VNI(s): ${NS_VXLAN_IDS[*]}${NC}\n"

echo -e "  ${BOLD}Test with ping:${NC}"
for (( i=0; i<NS_COUNT; i++ )); do
    echo -e "  ${CYAN}sudo ip netns exec ${NS_NAMES[$i]} ping <remote-namespace-IP>${NC}"
done

echo ""
echo -e "  ${BOLD}Start a web server inside a namespace:${NC}"
for (( i=0; i<NS_COUNT; i++ )); do
    echo -e "  ${CYAN}sudo ip netns exec ${NS_NAMES[$i]} python3 -m http.server 8080${NC}"
done

echo ""
echo -e "  ${BOLD}Useful commands:${NC}"
echo -e "  ${CYAN}ip netns list${NC}                    list all namespaces"
echo -e "  ${CYAN}sudo ip netns exec <n> bash${NC}      open shell inside namespace"
echo -e "  ${CYAN}bridge link show${NC}                 show all bridge ports"
echo -e "  ${CYAN}bridge fdb show${NC}                  show VXLAN forwarding table"
echo ""

# =============================================================================
#  STEP 10 — Generate teardown script
# =============================================================================
TEARDOWN_SCRIPT="./vxlan-teardown-$(date +%Y%m%d-%H%M%S).sh"

{
    echo "#!/usr/bin/env bash"
    echo "# Auto-generated teardown — reverses vxlan-setup.sh"
    echo "# Generated: $(date)"
    echo "set -euo pipefail"
    echo 'echo "Tearing down VXLAN configuration..."'
    for (( i=NS_COUNT-1; i>=0; i-- )); do
        echo "# Namespace ${NS_NAMES[$i]}"
        echo "ip link set ${NS_VXLAN_NAMES[$i]} down 2>/dev/null && ip link del ${NS_VXLAN_NAMES[$i]} 2>/dev/null || true"
        echo "ip link set ${NS_VOUT_NAMES[$i]} down 2>/dev/null && ip link del ${NS_VOUT_NAMES[$i]} 2>/dev/null || true"
        echo "ip netns del ${NS_NAMES[$i]} 2>/dev/null || true"
    done
    declare -A SEEN_BR=()
    for (( i=0; i<NS_COUNT; i++ )); do
        BR="${NS_BRIDGE_NAMES[$i]}"
        if [[ ! -v "SEEN_BR[$BR]" ]]; then
            echo "ip link set $BR down 2>/dev/null && ip link del $BR 2>/dev/null || true"
            SEEN_BR["$BR"]=1
        fi
    done
    echo 'echo "Teardown complete."'
} > "$TEARDOWN_SCRIPT"

chmod +x "$TEARDOWN_SCRIPT"
echo -e "  ${BOLD}Teardown script saved:${NC} ${CYAN}${TEARDOWN_SCRIPT}${NC}"
echo -e "  Run it to undo all changes.\n"

if $ALL_OK; then
    echo -e "\n${BOLD}${GREEN}  ✓ Setup complete. All checks passed.${NC}\n"
else
    echo -e "\n${BOLD}${YELLOW}  ⚠ Setup complete with warnings. Review output above.${NC}\n"
fi